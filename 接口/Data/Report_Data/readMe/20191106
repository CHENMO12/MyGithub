1. 平台下: 模拟平台登录,解决接口加密签名问题

2. 模块下: 在apiInfo_[module_key].yaml文件中,编写接口信息.
	<<接口信息编写规范>>
        yaml使用缩进表示层级关系, 目前接口管理为四个层级.
        第1层级: 模块名字
            简称: module_key, 是平台下的某个模块名字
            module_key在整个项目中需要具有唯一性
        第2层级: 接口名字
            简称: func_key, 是模块下的某个接口名字
            func_key可以是: add, delete, detail, list, listAll, edit 等
            若业务需要,可进行小驼峰命名
        第3层级: 接口信息详情
            接口详细信息包含接口描述(desc),请求url(url),请求端口(port),请求方法(method),请求内容类型(contentType),请求数据(data)
            port: 如果接口端口和web访问端口一致, 可不填写
            method: 可选项有 get, post, put, delete
            contentType: 可选项有 urlencoded, json, file
            data: 请求数据, 具体内容放在第4层级
        第4层级:
            请求数据为 k:v 格式
            其中v是实际的接口参数, k是对v参数的自定义命名
            一般规则: 小驼峰
                module_key + 参数属性
                depend + 参数属性

            时间命名问题:

                形如: 1999-08-08 23:23:59

                年月日 时分秒 时间戳
                startDate: 1999-08-08
                startTime: 23:23:59
                startDateTime : 1999-08-08 23:23:59
                startTimestamp : 179874834728

3. 模块下: 通过bns/cli.py,完成bns api和scn api的编写.
	执行bns/cli.py, 需要传入三个参数, 且每次只能基于一个接口来生成代码.
	bns api: 每个接口都存在bns api
		base/decorators.py下定义了几个装饰器
			api_retry: 如果发生了已知业务异常,有重新请求的机会
			api_wait: 如果查询结果不符合期望值,有重新请求的机会
		注意不同类型接口,应该配备不同的装饰器
			api_retry: 通常用在新增接口或编辑接口
			api_wait: 通常用在获取数据的接口
	scn api: 目前只有新增接口(add)存在scn api
		1. 先将参数分为三类: 固定参数, 简单随机参数, 依赖参数
		2. 如果函数参数是依赖参数,则依赖参数不给默认值; 同时在参数化部分删除相关代码
		3. 如果是固定参数,直接给该参数赋值.同时在函数入参中删除该参数.
			因为固定参数的不同, api可能分为多个更具体的场景api, 其命名参照fixed_testData
		4. 如果是简单随机参数,使用快捷键alt+enter来快速生成不存在的方法，并完成参数化
		5. 结果收集：
			所有的接口入参都会被收集
			其他内容的收集：如唯一性信息的收集
				1. 从接口响应信息中收集
				2. 通过列表的筛选查询内容中收集
		6. 已知异常码收集:如果因为唯一标识冲突导致的接口访问失败,这样的异常应该被捕获
		注意: 所有字段必须写全,否则编辑的用例会报错

4. 用例层--字段级:
	编写字段级用例: base/field_rank
	执行base/cil.py, 需要传入三个参数, 注意如果文件已存在会生成失败
	思路:
		验证必填字段,字段长度,字段类型

5. 用例层--模块级:
	编写模块级用例: base/module_rank
	执行base/cil.py, 需要传入三个参数, 注意如果文件已存在会生成失败
	思路:
		验证的api一定是bns api
		数据关联问题使用pytest的fixture解决
		基于一张表的增删改查功能设计用例
	写完用例后, 确认是否有可以复用的部分(验证步骤, 清理用例数据), 抽离出来放到utils.py中
	视情况而定,是否写成多个测试类


	fixture的使用规则:
		函数命名: 使用中文
		命名格式: 关联_xxx, 已使用_xxx
		fixture存放位置:
			1. 一般情况下, 写在py文件中class类的上边
			2. 必要时,可以写在类的内部. 如设计编辑功能的用例
			3. 在整合各模块用例时, 可以考虑抽离部分fixture函数写入conftest.py文件
		fixture的调用频率问题
			1. 默认是function级调用, 也是最常见的使用情况.
			2. 必要时,考虑class级调用, 如设计列表功能的用例

	编辑功能:
		必要时, 一些夹具可以写在类的内部
	列表功能:
		运用fixture的scope和autouse
